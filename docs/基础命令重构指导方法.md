# 基础命令重构指导方法

## 1. 依赖关系

基础命令通常使用C语言编写，而且通常将大量二进制放在一个文件夹中，很多时候包含额外的依赖关系。比如coreutils-9.0中，在src文件夹内包含了所有的二进制文件和一些库文件，而在lib文件夹中包含了所有的GNUlib库文件。这些文件之间的依赖关系错综复杂，人工梳理这些依赖关系显得非常不现实。

我们可以利用deps-exporter + deps-builder工具来自动分析依赖关系。先利用Bear等工具获取在编译基础命令时所调用的所有编译命令，得到Clang格式的compile_command.json文件。然后基于该文件通过Clang解析编译期间所涉及的所有C语言文件进行语法树解析，对不同文件之间语法树中出现的调用关系进行提取。最终构建得到整个项目的依赖关系。

当然，如果不局限于分析依赖关系。还可以直接使用ec2rust-transpile工具将C语言代码转换为包含依赖分析的Rust代码，这样可以更好地维护和扩展基础命令。

## 2. 代码重构

重构代码中需要注意分析基础命令的文件结构。比如对于coreutils来说，二进制全部包含在src中，GNUlib作为一个嵌入式的库文件无法单独提取出来作为库使用。对于这种情况我们通常将整个项目作为一个crate，然后将所有的二进制文件放在src中，然后构建全局的依赖关系。而如果是类似binutils的项目结构而言，binutils内置了多个文件夹作为库来使用，比如bfd、libiberty等。这种情况下，我们可以考虑针对不同文件夹创建Rust的crate，然后在主crate中通过Cargo.toml文件来创建库之间的依赖关系。

## 3. 代码测试

详情可以见[兼容性适配与验证](./兼容性适配与验证.md)和[稳定性与性能测试](./稳定性与性能测试.md)。

## 4. Safe Rust

对于如何将unsafe代码转换为safe代码，我们总结了以下几个指导方法：

1. 使用安全的替代方案替代C中裸指针的使用
裸指针操作可能会绕过 Rust 的所有权和生命周期检查，容易导致未定义行为。可以通过使用 Rust 提供的安全引用类型（如 &T 或 &mut T）来替代裸指针操作。如果确实需要使用裸指针，可以将其操作封装在一个安全的抽象中，确保外部调用者只使用安全的接口。
2. 使用 Rust 提供的内存管理工具
手动分配和释放内存是导致悬垂指针和内存泄漏的常见原因。尽量避免直接操作内存分配接口（如 std::alloc），而是使用 Rust 提供的内存管理工具，例如 Box 用于堆内存分配，Rc 和 Arc 用于引用计数管理，以及 Vec 用于动态数组管理。这些工具能够自动处理内存的分配和释放，避免资源管理问题。
3. 检查数组和内存的边界条件
在 unsafe 块中，操作数组或内存时没有边界检查，可能导致越界访问。可以通过增加显式的边界检查来避免此问题。最好使用 Rust 提供的切片或集合类型，因为它们自带边界检查功能。如果必须使用指针访问，务必手动验证指针的有效性和范围。
4. 尽量将 unsafe 代码封装在最小范围内
当必须使用 unsafe 代码时，应将其限制在一个尽可能小的范围内，并在封装时提供安全的接口。这样可以减少暴露给用户的不安全行为，同时降低调试和维护的复杂度。
5. 逐步替换和验证 unsafe 代码
将 unsafe 代码安全化时，不应一次性进行大规模重构，而是逐步分阶段替换。每次修改后都需要进行全面的测试，确保修改后的代码依然符合功能需求。可以通过单元测试、集成测试和边界测试来验证代码的安全性。
